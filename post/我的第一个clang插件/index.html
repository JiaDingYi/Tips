<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>我的第一个Clang插件 | Tips</title><meta name=keywords content="llvm"><meta name=description content="概念 编译的主要流程 输入文件 预处理 编译阶段 后端 链接 绑定 如何利用Clang提升开发质量 Clang提供了什么能力？ libClang Clang Plugins LibTooling 我的第一个Clang插件 编译 llvm-project 编写clang plugin的准备工作 编写clang plugin Xcode集成Clang插件 指定clang 关闭 Enable Index-While-Building Functionality 指定需要额外加载的clang plugin 编译结果 我的第一个LibTooling 使用ninja编译llvm项目 创建libtooling 使用LibTooling 概念 LLVM Low Level Virtual Machine，由 Chris Lattner（Swift 作者） 用于 Objective-C 和 Swift 的编译，后来又加上了很多功能可用于常规编译器、JIT 编译器、调试器、静态分析工具等。总结来说，LLVM 是工具链技术与一个模块化和可重用的编译器的集合。 Clang 是 LLVM 的子项目，可以对 C、C++和 Objective-C 进行快速编译，编译速度比 GCC 快 3 倍。Clang 可以认为是 Objective-C 的编译前端，LLVM 是编译后端，前端调用后端接口完成任务。Swift 则有自己的编译前端 SIL optimizer，编译后端同样用的是 LLVM。 AST 抽象语法树，按照层级关系排列。 IR 中间语言，具有与语言无关的特性，整体结构为 Module(一个文件)&ndash;Function&ndash;Basic Block–Instruction(指令)。 编译器 编译器用于把代码编译成机器码，机器码可以直接在 CPU 上面运行。好处是运行效率高，坏处是调试周期长，需要重新编译一次（OC 改完代码需要重新运行）。 解释器 解释器会在运行时解释执行代码，会一段一段的把代码翻译成目标代码，然后执行目标代码。好处是具有动态性，调试及时（类似 Flutter、Playground），坏处是执行效率低。平时在调试代码的时候，使用解释器会提高效率。 编译的主要流程 通过命令行查看源码的编译流程"><meta name=author content="Jdy"><link rel=canonical href=https://jiadingyi.github.io/Tips/post/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAclang%E6%8F%92%E4%BB%B6/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/Tips/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/Tips/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://jiadingyi.github.io/Tips/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://jiadingyi.github.io/Tips/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://jiadingyi.github.io/Tips/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://jiadingyi.github.io/Tips/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://jiadingyi.github.io/Tips/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="我的第一个Clang插件"><meta property="og:description" content="概念 编译的主要流程 输入文件 预处理 编译阶段 后端 链接 绑定 如何利用Clang提升开发质量 Clang提供了什么能力？ libClang Clang Plugins LibTooling 我的第一个Clang插件 编译 llvm-project 编写clang plugin的准备工作 编写clang plugin Xcode集成Clang插件 指定clang 关闭 Enable Index-While-Building Functionality 指定需要额外加载的clang plugin 编译结果 我的第一个LibTooling 使用ninja编译llvm项目 创建libtooling 使用LibTooling 概念 LLVM Low Level Virtual Machine，由 Chris Lattner（Swift 作者） 用于 Objective-C 和 Swift 的编译，后来又加上了很多功能可用于常规编译器、JIT 编译器、调试器、静态分析工具等。总结来说，LLVM 是工具链技术与一个模块化和可重用的编译器的集合。 Clang 是 LLVM 的子项目，可以对 C、C++和 Objective-C 进行快速编译，编译速度比 GCC 快 3 倍。Clang 可以认为是 Objective-C 的编译前端，LLVM 是编译后端，前端调用后端接口完成任务。Swift 则有自己的编译前端 SIL optimizer，编译后端同样用的是 LLVM。 AST 抽象语法树，按照层级关系排列。 IR 中间语言，具有与语言无关的特性，整体结构为 Module(一个文件)&ndash;Function&ndash;Basic Block–Instruction(指令)。 编译器 编译器用于把代码编译成机器码，机器码可以直接在 CPU 上面运行。好处是运行效率高，坏处是调试周期长，需要重新编译一次（OC 改完代码需要重新运行）。 解释器 解释器会在运行时解释执行代码，会一段一段的把代码翻译成目标代码，然后执行目标代码。好处是具有动态性，调试及时（类似 Flutter、Playground），坏处是执行效率低。平时在调试代码的时候，使用解释器会提高效率。 编译的主要流程 通过命令行查看源码的编译流程"><meta property="og:type" content="article"><meta property="og:url" content="https://jiadingyi.github.io/Tips/post/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAclang%E6%8F%92%E4%BB%B6/"><meta property="og:image" content="https://jiadingyi.github.io/Tips/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-05-30T11:00:37+08:00"><meta property="article:modified_time" content="2023-05-30T11:00:37+08:00"><meta property="og:site_name" content="Tips"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://jiadingyi.github.io/Tips/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="我的第一个Clang插件"><meta name=twitter:description content="概念 编译的主要流程 输入文件 预处理 编译阶段 后端 链接 绑定 如何利用Clang提升开发质量 Clang提供了什么能力？ libClang Clang Plugins LibTooling 我的第一个Clang插件 编译 llvm-project 编写clang plugin的准备工作 编写clang plugin Xcode集成Clang插件 指定clang 关闭 Enable Index-While-Building Functionality 指定需要额外加载的clang plugin 编译结果 我的第一个LibTooling 使用ninja编译llvm项目 创建libtooling 使用LibTooling 概念 LLVM Low Level Virtual Machine，由 Chris Lattner（Swift 作者） 用于 Objective-C 和 Swift 的编译，后来又加上了很多功能可用于常规编译器、JIT 编译器、调试器、静态分析工具等。总结来说，LLVM 是工具链技术与一个模块化和可重用的编译器的集合。 Clang 是 LLVM 的子项目，可以对 C、C++和 Objective-C 进行快速编译，编译速度比 GCC 快 3 倍。Clang 可以认为是 Objective-C 的编译前端，LLVM 是编译后端，前端调用后端接口完成任务。Swift 则有自己的编译前端 SIL optimizer，编译后端同样用的是 LLVM。 AST 抽象语法树，按照层级关系排列。 IR 中间语言，具有与语言无关的特性，整体结构为 Module(一个文件)&ndash;Function&ndash;Basic Block–Instruction(指令)。 编译器 编译器用于把代码编译成机器码，机器码可以直接在 CPU 上面运行。好处是运行效率高，坏处是调试周期长，需要重新编译一次（OC 改完代码需要重新运行）。 解释器 解释器会在运行时解释执行代码，会一段一段的把代码翻译成目标代码，然后执行目标代码。好处是具有动态性，调试及时（类似 Flutter、Playground），坏处是执行效率低。平时在调试代码的时候，使用解释器会提高效率。 编译的主要流程 通过命令行查看源码的编译流程"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://jiadingyi.github.io/Tips/post/"},{"@type":"ListItem","position":2,"name":"我的第一个Clang插件","item":"https://jiadingyi.github.io/Tips/post/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAclang%E6%8F%92%E4%BB%B6/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"我的第一个Clang插件","name":"我的第一个Clang插件","description":"概念 编译的主要流程 输入文件 预处理 编译阶段 后端 链接 绑定 如何利用Clang提升开发质量 Clang提供了什么能力？ libClang Clang Plugins LibTooling 我的第一个Clang插件 编译 llvm-project 编写clang plugin的准备工作 编写clang plugin Xcode集成Clang插件 指定clang 关闭 Enable Index-While-Building Functionality 指定需要额外加载的clang plugin 编译结果 我的第一个LibTooling 使用ninja编译llvm项目 创建libtooling 使用LibTooling 概念 LLVM Low Level Virtual Machine，由 Chris Lattner（Swift 作者） 用于 Objective-C 和 Swift 的编译，后来又加上了很多功能可用于常规编译器、JIT 编译器、调试器、静态分析工具等。总结来说，LLVM 是工具链技术与一个模块化和可重用的编译器的集合。 Clang 是 LLVM 的子项目，可以对 C、C++和 Objective-C 进行快速编译，编译速度比 GCC 快 3 倍。Clang 可以认为是 Objective-C 的编译前端，LLVM 是编译后端，前端调用后端接口完成任务。Swift 则有自己的编译前端 SIL optimizer，编译后端同样用的是 LLVM。 AST 抽象语法树，按照层级关系排列。 IR 中间语言，具有与语言无关的特性，整体结构为 Module(一个文件)\u0026ndash;Function\u0026ndash;Basic Block–Instruction(指令)。 编译器 编译器用于把代码编译成机器码，机器码可以直接在 CPU 上面运行。好处是运行效率高，坏处是调试周期长，需要重新编译一次（OC 改完代码需要重新运行）。 解释器 解释器会在运行时解释执行代码，会一段一段的把代码翻译成目标代码，然后执行目标代码。好处是具有动态性，调试及时（类似 Flutter、Playground），坏处是执行效率低。平时在调试代码的时候，使用解释器会提高效率。 编译的主要流程 通过命令行查看源码的编译流程","keywords":["llvm"],"articleBody":" 概念 编译的主要流程 输入文件 预处理 编译阶段 后端 链接 绑定 如何利用Clang提升开发质量 Clang提供了什么能力？ libClang Clang Plugins LibTooling 我的第一个Clang插件 编译 llvm-project 编写clang plugin的准备工作 编写clang plugin Xcode集成Clang插件 指定clang 关闭 Enable Index-While-Building Functionality 指定需要额外加载的clang plugin 编译结果 我的第一个LibTooling 使用ninja编译llvm项目 创建libtooling 使用LibTooling 概念 LLVM Low Level Virtual Machine，由 Chris Lattner（Swift 作者） 用于 Objective-C 和 Swift 的编译，后来又加上了很多功能可用于常规编译器、JIT 编译器、调试器、静态分析工具等。总结来说，LLVM 是工具链技术与一个模块化和可重用的编译器的集合。 Clang 是 LLVM 的子项目，可以对 C、C++和 Objective-C 进行快速编译，编译速度比 GCC 快 3 倍。Clang 可以认为是 Objective-C 的编译前端，LLVM 是编译后端，前端调用后端接口完成任务。Swift 则有自己的编译前端 SIL optimizer，编译后端同样用的是 LLVM。 AST 抽象语法树，按照层级关系排列。 IR 中间语言，具有与语言无关的特性，整体结构为 Module(一个文件)–Function–Basic Block–Instruction(指令)。 编译器 编译器用于把代码编译成机器码，机器码可以直接在 CPU 上面运行。好处是运行效率高，坏处是调试周期长，需要重新编译一次（OC 改完代码需要重新运行）。 解释器 解释器会在运行时解释执行代码，会一段一段的把代码翻译成目标代码，然后执行目标代码。好处是具有动态性，调试及时（类似 Flutter、Playground），坏处是执行效率低。平时在调试代码的时候，使用解释器会提高效率。 编译的主要流程 通过命令行查看源码的编译流程\n➜ bin git:(main) ✗ ./clang -isysroot /Applications/Xcode_14.0.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator16.0.sdk/ -ccc-print-phases /Users/wangzeyong/Desktop/llvm-all/ACKTestApp/ACKTestApp/ViewController.m +- 0: input, \"/Users/wangzeyong/Desktop/llvm-all/ACKTestApp/ACKTestApp/ViewController.m\", objective-c +- 1: preprocessor, {0}, objective-c-cpp-output +- 2: compiler, {1}, ir +- 3: backend, {2}, assembler +- 4: assembler, {3}, object +- 5: linker, {4}, image 6: bind-arch, \"arm64\", {5}, image 输入文件 找到源文件。\"/Users/wangzeyong/Desktop/llvm-all/ACKTestApp/ACKTestApp/ViewController.m\", objective-c 预处理 处理宏替换，头文件的导入\nclang -isysroot /Applications/Xcode_14.0.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator16.0.sdk/ -E /Users/wangzeyong/Desktop/llvm-all/ACKTestApp/ACKTestApp/ViewController.m \u003e\u003e ViewController2.m ViewController2\n编译阶段 词法分析、语法分析、检测语法是否正确，生成中间代码IR\n词法分析。会把代码切成一个个token，比如大小括号，等于号等等 clang -isysroot /Applications/Xcode_14.0.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator16.0.sdk/ -fmodules -fsyntax-only -Xclang -dump-tokens /Users/wangzeyong/Desktop/llvm-all/ACKTestApp/ACKTestApp/ViewController.m 词法分析 语法分析。生成语法树 ./clang -isysroot /Applications/Xcode_14.0.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator16.0.sdk/ -fmodules -fsyntax-only -Xclang -ast-dump /Users/wangzeyong/Desktop/llvm-all/ACKTestApp/ACKTestApp/ViewController.m 语法分析 其中，主要说明几个关键字的含义 FunctionDecl 函数 ParmVarDecl 参数 CallExpr 调用一个函数 BinaryOperator 运算符 生成中间代码IR 后端 llvm通过pass优化，最终生成汇编代码\n链接 链接需要的动态库和静态库，生成可执行文件\n绑定 通过不同的架构，生成对应的可执行文件\n如何利用Clang提升开发质量 工作中，经常发生线上事故，复盘时很多都是因为代码不规范导致。 代码规范执行不到位，从而导致代码质量差，无法监管，我们才被动处理线上事故。 那我们到底怎么改善呢？ 好的监控手段需要我们自己动手建设，通过clang提供的丰富接口功能，我们可以开发出静态分析工具，进而管控代码质量。\nClang提供了什么能力？ libClang LibClang 提供了稳定的高级C接口，Xcode使用的就是LibClang。 LibClang 可以访问 Clang 的上层高级抽象的能力，比如获取所有的 Token、遍历语法树、代码补全等。 由于 API 很稳定， Clang 版本更新对其影响不大。 但是 LibClang 并不能完全访问到 Clang AST 信息。\nClang Plugins Clang Plugins 可以让你在 AST 上做些操作，这些操作能够集成到编译中，成为编译的一部分。 插件是在运行时由编译器加载的动态库，方便集成到构建系统中。 使用 Clang Plugins 一般都是希望能够完全控制 Clang AST，同时能够集成在编译流程中，可以影响编译的过程，进行中断或者提示。\nLibTooling LibTooling 是一个 C++ 接口，通过 LibTooling 能够编写独立运行的语法检查和代码重构工具。 LibTooling 的优势如下：\n所写的工具不依赖于构建系统，可以作为一个命令单独使用，比如 clang-check、clang-fixit、clang-format； 可以完全控制 Clang AST； 能够和 Clang Plugins 共用一份代码。 与 Clang Plugins 相比，LibTooling 无法影响编译过程； 与 LibClang 相比，LibTooling 的接口没有那么稳定，也无法开箱即用，当 AST 的 API 升级后需要更新接口的调用。 但是，LibTooling 基于能够完全控制 Clang AST 和可独立运行的特点，可以做的事情就非常多了。\n改变代码：可以改变 Clang 生成代码的方式。基于现有代码可以做出大量的修改。还可以进行语言的转换，比如把 OC 语言转成 JavaScript 或者 Swift。 做检查：检查命名规范，增加更强的类型检查，还可以按照自己的定义进行代码的检查分析。 做分析：对源码做任意类型分析，甚至重写程序。给 Clang 添加一些自定义的分析，创建自己的重构器，还可以基于工程生成相关图形或文档进行分析。 我的第一个Clang插件 编译 llvm-project git clone https://github.com/llvm/llvm-project.git cd llvm-project mkdir build cd build cmake -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G Xcode ../llvm 使用Xcode编译项目，方便编写cpp文件 也可使用官方推荐的其他方式编译，例如：Ninja（速度相对快一些） 如果本地没有安装cmake，则需要安装。brew install cmake open LLVM.xcodeproj 选中Automatically Creat Schemes后，在选择all_build，cmd+b即可开始编译 个人习惯选择all_build,也可选择手动创建需要的schemes M1选择all_build速度比传闻的一小时要快很多，我的电脑大概十几分钟 记录编译出来的clang、clang++（后面有用） /Users/xxx/Desktop/llvm-all/llvm-project/build/Debug/bin/clang /Users/xxx/Desktop/llvm-all/llvm-project/build/Debug/bin/clang++ 编写clang plugin的准备工作 cd /llvm-project/clang/tools mkdir ACKClangPlugin cd ACKClangPlugin touch ACKClangPlugin.cpp touch CMakeLists.txt st CMakeLists.txt（打开CMakeLists.txt文件，添加下一步的描述文字） add_llvm_library( ACKClangPlugin MODULE ACKClangPlugin.cpp) cd .. st CMakeLists.txt(打开llvm-project/clang/tools下的CMakeLists.txt文件，并添加下一步的描述文字) add_clang_subdirectory(ACKClangPlugin) 编写clang plugin cd /llvm-project/build cmake -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G Xcode ../llvm (重新编译Xcode工程) open LLVM.xcodeproj 重新选择Automatically Creat Schemes 此时项目中已经有ACKClangPlugin.cpp文件，我们的插件在此编写 #include #include \"clang/AST/AST.h\" #include \"clang/AST/ASTConsumer.h\" #include \"clang/ASTMatchers/ASTMatchers.h\" #include \"clang/ASTMatchers/ASTMatchFinder.h\" #include \"clang/Frontend/CompilerInstance.h\" #include \"clang/Frontend/FrontendPluginRegistry.h\" using namespace clang; using namespace std; using namespace llvm; using namespace clang::ast_matchers; namespace ACKClangPlugin { class TestHandler : public MatchFinder::MatchCallback{ private: CompilerInstance \u0026ci; public: TestHandler(CompilerInstance \u0026ci) :ci(ci) {} //判断是否是用户源文件 bool isUserSourceCode(const string filename) { //文件名不为空 if (filename.empty()) return false; //非xcode中的源码都认为是用户的 if (filename.find(\"/Applications/Xcode_14.0.app/\") == 0) return false; return true; } // 代码检查的回调方法 void run(const MatchFinder::MatchResult \u0026Result) { // 检查类名(Interface)，不能带有下划线 if (const ObjCInterfaceDecl *decl = Result.Nodes.getNodeAs\u003cObjCInterfaceDecl\u003e(\"ObjCInterfaceDecl\")) { string filename = ci.getSourceManager().getFilename(decl-\u003egetSourceRange().getBegin()).str(); if ( !isUserSourceCode(filename) ) return; size_t pos = decl-\u003egetName().find('_'); if (pos != StringRef::npos) { DiagnosticsEngine \u0026D = ci.getDiagnostics(); // 获取位置 SourceLocation loc = decl-\u003egetLocation().getLocWithOffset(pos); D.Report(loc, D.getCustomDiagID(DiagnosticsEngine::Warning, \"ACKClangPlugin：类名中不能带有下划线\")); } } // 检查变量(Interface)，不能带有下划线 if (const VarDecl *decl = Result.Nodes.getNodeAs\u003cVarDecl\u003e(\"VarDecl\")) { string filename = ci.getSourceManager().getFilename(decl-\u003egetSourceRange().getBegin()).str(); if ( !isUserSourceCode(filename) ) return; size_t pos = decl-\u003egetName().find('_'); if (pos != StringRef::npos \u0026\u0026 pos != 0) { DiagnosticsEngine \u0026D = ci.getDiagnostics(); SourceLocation loc = decl-\u003egetLocation().getLocWithOffset(pos); D.Report(loc, D.getCustomDiagID(DiagnosticsEngine::Warning, \"ACKClangPlugin：请使用驼峰命名，不建议使用下划线\")); D.Report(loc, D.getCustomDiagID(DiagnosticsEngine::Error, \"ACKClangPlugin: 请使用驼峰命名，不建议使用下划线\")); } } } }; // 定义语法树的接受事件 class TestASTConsumer: public ASTConsumer{ private: MatchFinder matcher; TestHandler handler; public: TestASTConsumer(CompilerInstance \u0026ci) :handler(ci) { matcher.addMatcher(objcInterfaceDecl().bind(\"ObjCInterfaceDecl\"), \u0026handler); matcher.addMatcher(varDecl().bind(\"VarDecl\"), \u0026handler); matcher.addMatcher(objcMethodDecl().bind(\"ObjCMethodDecl\"), \u0026handler); } void HandleTranslationUnit(ASTContext \u0026Ctx) { printf(\"ACKClangPlugin: All ASTs has parsed.\"); DiagnosticsEngine \u0026D = Ctx.getDiagnostics(); matcher.matchAST(Ctx); } }; // 定义触发插件的动作 class TestAction : public PluginASTAction{ public: unique_ptr\u003cASTConsumer\u003e CreateASTConsumer(CompilerInstance \u0026CI, StringRef InFile){ return unique_ptr\u003cTestASTConsumer\u003e (new TestASTConsumer(CI)); } bool ParseArgs(const CompilerInstance \u0026CI, const std::vector\u003cstd::string\u003e \u0026arg){ return true; } }; } // 告知clang,注册一个新的plugin static FrontendPluginRegistry::Add\u003cACKClangPlugin::TestAction\u003e X(\"ACKClangPlugin\", \"ACKClangPlugin a new Plugin\"); // X 变量名，可随便写，也可以写自己有意思的名称 // ACKClangPlugin 插件名称，️很重要，这个是对外的名称 // ACKClangPlugin a new Plugin 插件备注 scheme中选择ACKClangPlugin，编译。 记录编译出的ACKClangPlugin.dylib路径 /Users/xxx/Desktop/llvm-all/llvm-project/build/Debug/lib/ACKClangPlugin.dylib Xcode集成Clang插件 指定clang Xcode默认使用的是自带的clang前端，所以在Xcode中我们需要增加CC和CXX参数来指定我们自己的clang地址。 在配置文件中新增CC和CXX绝对路径，也就是clang和clang++的绝对路径 注：在编译llvm-project中有记录 /// 注意：key为大写。 CC = /Users/wangzeyong/Desktop/llvm-all/llvm-project/build/Debug/bin/clang CXX =/Users/wangzeyong/Desktop/llvm-all/llvm-project/build/Debug/bin/clang++ 关闭 Enable Index-While-Building Functionality 指定需要额外加载的clang plugin 在配置文件中搜索other c即可快速查询 增加如下内容 -Xclang -load 插件地址(dylib的地址) -Xclang -add-plugin -Xclang 插件名 // 实例 -Xclang -load -Xclang /Volumes/ExDisk/LLVM/llvm/llvm_xcode/Debug/lib/TestPlugin1.dylib -Xclang -add-plugin -Xclang TestPlugin 编译结果 我的第一个LibTooling 使用ninja编译llvm项目 cd llvm-project mkdir ninja cd ninja cmake -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G Ninja ../llvm 如果没有ninja，则需要安装。brew install ninja ninja ninja install 创建libtooling cd llvm-project cd clang/tools mkdir ACKLibTooling cd ACKLibTooling touch ACKLibTooling.cpp touch CMakeLists.txt code CMakeLists.txt (打开文件，并添加下一步的描述) set(LLVM_LINK_COMPONENTS support) add_clang_tool(ACKLibTooling ACKLibTooling.cpp ) clang_target_link_libraries(ACKLibTooling PRIVATE clangAST clangASTMatchers clangBasic clangFrontend clangSerialization clangTooling ) cd ../ echo ‘add_subdirectory(ACKLibTooling)’ » CMakeLists.txt code ACKLibTooling.cpp (打开文件，并添加下一步的代码) // Declares clang::SyntaxOnlyAction. #include \"clang/Frontend/FrontendActions.h\" #include \"clang/Tooling/CommonOptionsParser.h\" #include \"clang/Tooling/Tooling.h\" // Declares llvm::cl::extrahelp. #include \"llvm/Support/CommandLine.h\" #include \"clang/ASTMatchers/ASTMatchers.h\" #include \"clang/ASTMatchers/ASTMatchFinder.h\" using namespace llvm; using namespace clang; using namespace clang::tooling; using namespace clang::ast_matchers; // Apply a custom category to all command-line options so that they are the // only ones displayed. static llvm::cl::OptionCategory MyToolCategory(\"my-tool options\"); // CommonOptionsParser declares HelpMessage with a description of the common // command-line options related to the compilation database and input files. // It's nice to have this help message in all tools. static cl::extrahelp CommonHelp(CommonOptionsParser::HelpMessage); // A help message for this specific tool can be added afterwards. static cl::extrahelp MoreHelp(\"\\nMore help text...\\n\"); StatementMatcher LoopMatcher = forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl( hasInitializer(integerLiteral(equals(0)))))))).bind(\"forLoop\"); class LoopPrinter : public MatchFinder::MatchCallback { public : virtual void run(const MatchFinder::MatchResult \u0026Result) { // 绑定for循环 if (const ForStmt *FS = Result.Nodes.getNodeAs\u003cclang::ForStmt\u003e(\"forLoop\")) // 打印for循环表达式的抽象语法树 FS-\u003edump(); } }; int main(int argc, const char **argv) { auto ExpectedParser = CommonOptionsParser::create(argc, argv, MyToolCategory); if (!ExpectedParser) { // Fail gracefully for unsupported options. llvm::errs() \u003c\u003c ExpectedParser.takeError(); return 1; } CommonOptionsParser\u0026 OptionsParser = ExpectedParser.get(); ClangTool Tool(OptionsParser.getCompilations(), OptionsParser.getSourcePathList()); LoopPrinter Printer; MatchFinder Finder; Finder.addMatcher(LoopMatcher, \u0026Printer); return Tool.run(newFrontendActionFactory(\u0026Finder).get()); } cd llvm-project/ninja ninja 此时可见编译好的libtooling在llvm-project/ninja/bin/目录下 使用LibTooling 创建一个测试文件test.m int main(void) { int a = 0; for(int i= 0; i \u003c 10; ++i) { a += i; } return a; } ./bin/ACKLibTooling test.m for循环的抽象语法树被打印出来 ","wordCount":"904","inLanguage":"en","datePublished":"2023-05-30T11:00:37+08:00","dateModified":"2023-05-30T11:00:37+08:00","author":{"@type":"Person","name":"Jdy"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://jiadingyi.github.io/Tips/post/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAclang%E6%8F%92%E4%BB%B6/"},"publisher":{"@type":"Organization","name":"Tips","logo":{"@type":"ImageObject","url":"https://jiadingyi.github.io/Tips/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://jiadingyi.github.io/Tips/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jiadingyi.github.io/Tips/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://jiadingyi.github.io/Tips/>Home</a>&nbsp;»&nbsp;<a href=https://jiadingyi.github.io/Tips/post/>Posts</a></div><h1 class=post-title>我的第一个Clang插件</h1><div class=post-meta><span title='2023-05-30 11:00:37 +0800 CST'>May 30, 2023</span>&nbsp;·&nbsp;Jdy</div></header><div class=post-content><ul><li><a href=#%E6%A6%82%E5%BF%B5>概念</a></li><li><a href=#%E7%BC%96%E8%AF%91%E7%9A%84%E4%B8%BB%E8%A6%81%E6%B5%81%E7%A8%8B>编译的主要流程</a><ul><li><a href=#%E8%BE%93%E5%85%A5%E6%96%87%E4%BB%B6>输入文件</a></li><li><a href=#%E9%A2%84%E5%A4%84%E7%90%86>预处理</a></li><li><a href=#%E7%BC%96%E8%AF%91%E9%98%B6%E6%AE%B5>编译阶段</a></li><li><a href=#%E5%90%8E%E7%AB%AF>后端</a></li><li><a href=#%E9%93%BE%E6%8E%A5>链接</a></li><li><a href=#%E7%BB%91%E5%AE%9A>绑定</a></li></ul></li><li><a href=#%E5%A6%82%E4%BD%95%E5%88%A9%E7%94%A8clang%E6%8F%90%E5%8D%87%E5%BC%80%E5%8F%91%E8%B4%A8%E9%87%8F>如何利用Clang提升开发质量</a><ul><li><a href=#clang%E6%8F%90%E4%BE%9B%E4%BA%86%E4%BB%80%E4%B9%88%E8%83%BD%E5%8A%9B>Clang提供了什么能力？</a><ul><li><a href=#libclang>libClang</a></li><li><a href=#clang-plugins>Clang Plugins</a></li><li><a href=#libtooling>LibTooling</a></li></ul></li></ul></li><li><a href=#%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAclang%E6%8F%92%E4%BB%B6>我的第一个Clang插件</a><ul><li><a href=#%E7%BC%96%E8%AF%91-llvm-project>编译 llvm-project</a></li><li><a href=#%E7%BC%96%E5%86%99clang-plugin%E7%9A%84%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C>编写clang plugin的准备工作</a></li><li><a href=#%E7%BC%96%E5%86%99clang-plugin>编写clang plugin</a></li></ul></li><li><a href=#xcode%E9%9B%86%E6%88%90clang%E6%8F%92%E4%BB%B6>Xcode集成Clang插件</a><ul><li><a href=#%E6%8C%87%E5%AE%9Aclang>指定clang</a></li><li><a href=#%E5%85%B3%E9%97%AD-enable-index-while-building-functionality>关闭 Enable Index-While-Building Functionality</a></li><li><a href=#%E6%8C%87%E5%AE%9A%E9%9C%80%E8%A6%81%E9%A2%9D%E5%A4%96%E5%8A%A0%E8%BD%BD%E7%9A%84clang-plugin>指定需要额外加载的clang plugin</a></li><li><a href=#%E7%BC%96%E8%AF%91%E7%BB%93%E6%9E%9C>编译结果</a></li></ul></li><li><a href=#%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAlibtooling>我的第一个LibTooling</a><ul><li><a href=#%E4%BD%BF%E7%94%A8ninja%E7%BC%96%E8%AF%91llvm%E9%A1%B9%E7%9B%AE>使用ninja编译llvm项目</a></li><li><a href=#%E5%88%9B%E5%BB%BAlibtooling>创建libtooling</a></li><li><a href=#%E4%BD%BF%E7%94%A8libtooling>使用LibTooling</a></li></ul></li></ul><h1 id=概念>概念<a hidden class=anchor aria-hidden=true href=#概念>#</a></h1><ul><li>LLVM
Low Level Virtual Machine，由 Chris Lattner（Swift 作者） 用于 Objective-C 和 Swift 的编译，后来又加上了很多功能可用于常规编译器、JIT 编译器、调试器、静态分析工具等。总结来说，LLVM 是工具链技术与一个模块化和可重用的编译器的集合。</li><li>Clang
是 LLVM 的子项目，可以对 C、C++和 Objective-C 进行快速编译，编译速度比 GCC 快 3 倍。Clang 可以认为是 Objective-C 的编译前端，LLVM 是编译后端，前端调用后端接口完成任务。Swift 则有自己的编译前端 SIL optimizer，编译后端同样用的是 LLVM。</li><li>AST
抽象语法树，按照层级关系排列。</li><li>IR
中间语言，具有与语言无关的特性，整体结构为 Module(一个文件)&ndash;Function&ndash;Basic Block–Instruction(指令)。</li><li>编译器
编译器用于把代码编译成机器码，机器码可以直接在 CPU 上面运行。好处是运行效率高，坏处是调试周期长，需要重新编译一次（OC 改完代码需要重新运行）。</li><li>解释器
解释器会在运行时解释执行代码，会一段一段的把代码翻译成目标代码，然后执行目标代码。好处是具有动态性，调试及时（类似 Flutter、Playground），坏处是执行效率低。平时在调试代码的时候，使用解释器会提高效率。</li></ul><h1 id=编译的主要流程>编译的主要流程<a hidden class=anchor aria-hidden=true href=#编译的主要流程>#</a></h1><p><img loading=lazy src=./%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B.png alt=bianyiliucheng></p><p>通过命令行查看源码的编译流程</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>➜  bin git:<span style=color:#f92672>(</span>main<span style=color:#f92672>)</span> ✗ ./clang -isysroot /Applications/Xcode_14.0.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator16.0.sdk/ -ccc-print-phases  /Users/wangzeyong/Desktop/llvm-all/ACKTestApp/ACKTestApp/ViewController.m
</span></span><span style=display:flex><span>               +- 0: input, <span style=color:#e6db74>&#34;/Users/wangzeyong/Desktop/llvm-all/ACKTestApp/ACKTestApp/ViewController.m&#34;</span>, objective-c
</span></span><span style=display:flex><span>            +- 1: preprocessor, <span style=color:#f92672>{</span>0<span style=color:#f92672>}</span>, objective-c-cpp-output
</span></span><span style=display:flex><span>         +- 2: compiler, <span style=color:#f92672>{</span>1<span style=color:#f92672>}</span>, ir
</span></span><span style=display:flex><span>      +- 3: backend, <span style=color:#f92672>{</span>2<span style=color:#f92672>}</span>, assembler
</span></span><span style=display:flex><span>   +- 4: assembler, <span style=color:#f92672>{</span>3<span style=color:#f92672>}</span>, object
</span></span><span style=display:flex><span>+- 5: linker, <span style=color:#f92672>{</span>4<span style=color:#f92672>}</span>, image
</span></span><span style=display:flex><span>6: bind-arch, <span style=color:#e6db74>&#34;arm64&#34;</span>, <span style=color:#f92672>{</span>5<span style=color:#f92672>}</span>, image
</span></span></code></pre></div><h2 id=输入文件>输入文件<a hidden class=anchor aria-hidden=true href=#输入文件>#</a></h2><ul><li>找到源文件。<code>"/Users/wangzeyong/Desktop/llvm-all/ACKTestApp/ACKTestApp/ViewController.m", objective-c</code></li></ul><h2 id=预处理>预处理<a hidden class=anchor aria-hidden=true href=#预处理>#</a></h2><p>处理宏替换，头文件的导入</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>clang -isysroot /Applications/Xcode_14.0.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator16.0.sdk/ -E /Users/wangzeyong/Desktop/llvm-all/ACKTestApp/ACKTestApp/ViewController.m &gt;&gt; ViewController2.m
</span></span></code></pre></div><p><a href=./ViewController2.m>ViewController2</a></p><h2 id=编译阶段>编译阶段<a hidden class=anchor aria-hidden=true href=#编译阶段>#</a></h2><p>词法分析、语法分析、检测语法是否正确，生成中间代码IR</p><ul><li>词法分析。会把代码切成一个个token，比如大小括号，等于号等等<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>clang -isysroot /Applications/Xcode_14.0.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator16.0.sdk/ -fmodules -fsyntax-only -Xclang -dump-tokens /Users/wangzeyong/Desktop/llvm-all/ACKTestApp/ACKTestApp/ViewController.m
</span></span></code></pre></div><a href=./%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90.txt>词法分析</a></li><li>语法分析。生成语法树<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>./clang -isysroot /Applications/Xcode_14.0.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator16.0.sdk/ -fmodules -fsyntax-only -Xclang -ast-dump /Users/wangzeyong/Desktop/llvm-all/ACKTestApp/ACKTestApp/ViewController.m
</span></span></code></pre></div><img loading=lazy src=./image2022-11-3_19-5-40.png alt=语法分析>
<a href=./%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90.txt>语法分析</a>
其中，主要说明几个关键字的含义<ul><li>FunctionDecl 函数</li><li>ParmVarDecl 参数</li><li>CallExpr 调用一个函数</li><li>BinaryOperator 运算符</li></ul></li><li>生成中间代码IR</li></ul><h2 id=后端>后端<a hidden class=anchor aria-hidden=true href=#后端>#</a></h2><p>llvm通过pass优化，最终生成汇编代码</p><h2 id=链接>链接<a hidden class=anchor aria-hidden=true href=#链接>#</a></h2><p>链接需要的动态库和静态库，生成可执行文件</p><h2 id=绑定>绑定<a hidden class=anchor aria-hidden=true href=#绑定>#</a></h2><p>通过不同的架构，生成对应的可执行文件</p><h1 id=如何利用clang提升开发质量>如何利用Clang提升开发质量<a hidden class=anchor aria-hidden=true href=#如何利用clang提升开发质量>#</a></h1><p>工作中，经常发生线上事故，复盘时很多都是因为代码不规范导致。
代码规范执行不到位，从而导致代码质量差，无法监管，我们才被动处理线上事故。
那我们到底怎么改善呢？
好的监控手段需要我们自己动手建设，通过clang提供的丰富接口功能，我们可以开发出静态分析工具，进而管控代码质量。</p><h2 id=clang提供了什么能力>Clang提供了什么能力？<a hidden class=anchor aria-hidden=true href=#clang提供了什么能力>#</a></h2><h3 id=libclang>libClang<a hidden class=anchor aria-hidden=true href=#libclang>#</a></h3><p>LibClang 提供了稳定的高级C接口，Xcode使用的就是LibClang。
LibClang 可以访问 Clang 的上层高级抽象的能力，比如获取所有的 Token、遍历语法树、代码补全等。
由于 API 很稳定， Clang 版本更新对其影响不大。
但是 LibClang 并不能完全访问到 Clang AST 信息。</p><h3 id=clang-plugins>Clang Plugins<a hidden class=anchor aria-hidden=true href=#clang-plugins>#</a></h3><p>Clang Plugins 可以让你在 AST 上做些操作，这些操作能够集成到编译中，成为编译的一部分。
插件是在运行时由编译器加载的动态库，方便集成到构建系统中。
使用 Clang Plugins 一般都是希望能够完全控制 Clang AST，同时能够集成在编译流程中，可以影响编译的过程，进行中断或者提示。</p><h3 id=libtooling>LibTooling<a hidden class=anchor aria-hidden=true href=#libtooling>#</a></h3><p>LibTooling 是一个 C++ 接口，通过 LibTooling 能够编写独立运行的语法检查和代码重构工具。
LibTooling 的优势如下：</p><ul><li>所写的工具不依赖于构建系统，可以作为一个命令单独使用，比如 clang-check、clang-fixit、clang-format；</li><li>可以完全控制 Clang AST；</li><li>能够和 Clang Plugins 共用一份代码。</li></ul><p>与 Clang Plugins 相比，LibTooling 无法影响编译过程；
与 LibClang 相比，LibTooling 的接口没有那么稳定，也无法开箱即用，当 AST 的 API 升级后需要更新接口的调用。
但是，LibTooling 基于能够完全控制 Clang AST 和可独立运行的特点，可以做的事情就非常多了。</p><ul><li>改变代码：可以改变 Clang 生成代码的方式。基于现有代码可以做出大量的修改。还可以进行语言的转换，比如把 OC 语言转成 JavaScript 或者 Swift。</li><li>做检查：检查命名规范，增加更强的类型检查，还可以按照自己的定义进行代码的检查分析。</li><li>做分析：对源码做任意类型分析，甚至重写程序。给 Clang 添加一些自定义的分析，创建自己的重构器，还可以基于工程生成相关图形或文档进行分析。</li></ul><h1 id=我的第一个clang插件>我的第一个Clang插件<a hidden class=anchor aria-hidden=true href=#我的第一个clang插件>#</a></h1><h2 id=编译-llvm-project>编译 llvm-project<a hidden class=anchor aria-hidden=true href=#编译-llvm-project>#</a></h2><ul><li>git clone <a href=https://github.com/llvm/llvm-project.git>https://github.com/llvm/llvm-project.git</a></li><li>cd llvm-project</li><li>mkdir build</li><li>cd build</li><li>cmake -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G Xcode ../llvm<ul><li>使用Xcode编译项目，方便编写cpp文件</li><li>也可使用官方推荐的其他方式编译，例如：Ninja（速度相对快一些）</li><li>如果本地没有安装cmake，则需要安装。brew install cmake</li></ul></li><li>open LLVM.xcodeproj</li><li>选中Automatically Creat Schemes后，在选择all_build，cmd+b即可开始编译<ul><li>个人习惯选择all_build,也可选择手动创建需要的schemes</li><li>M1选择all_build速度比传闻的一小时要快很多，我的电脑大概十几分钟</li></ul></li><li>记录编译出来的clang、clang++（后面有用）<ul><li>/Users/xxx/Desktop/llvm-all/llvm-project/build/Debug/bin/clang</li><li>/Users/xxx/Desktop/llvm-all/llvm-project/build/Debug/bin/clang++</li></ul></li></ul><h2 id=编写clang-plugin的准备工作>编写clang plugin的准备工作<a hidden class=anchor aria-hidden=true href=#编写clang-plugin的准备工作>#</a></h2><ul><li>cd /llvm-project/clang/tools</li><li>mkdir ACKClangPlugin</li><li>cd ACKClangPlugin</li><li>touch ACKClangPlugin.cpp</li><li>touch CMakeLists.txt</li><li>st CMakeLists.txt（打开CMakeLists.txt文件，添加下一步的描述文字）</li><li>add_llvm_library( ACKClangPlugin MODULE ACKClangPlugin.cpp)</li><li>cd ..</li><li>st CMakeLists.txt(打开llvm-project/clang/tools下的CMakeLists.txt文件，并添加下一步的描述文字)</li><li>add_clang_subdirectory(ACKClangPlugin)</li></ul><h2 id=编写clang-plugin>编写clang plugin<a hidden class=anchor aria-hidden=true href=#编写clang-plugin>#</a></h2><ul><li>cd /llvm-project/build</li><li>cmake -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G Xcode ../llvm (重新编译Xcode工程)</li><li>open LLVM.xcodeproj</li><li>重新选择Automatically Creat Schemes</li><li>此时项目中已经有ACKClangPlugin.cpp文件，我们的插件在此编写</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>   <span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;iostream&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;clang/AST/AST.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;clang/AST/ASTConsumer.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;clang/ASTMatchers/ASTMatchers.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;clang/ASTMatchers/ASTMatchFinder.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;clang/Frontend/CompilerInstance.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;clang/Frontend/FrontendPluginRegistry.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> clang;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> std;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> llvm;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> clang<span style=color:#f92672>::</span>ast_matchers;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>namespace</span> ACKClangPlugin {
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestHandler</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> MatchFinder<span style=color:#f92672>::</span>MatchCallback{
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>           CompilerInstance <span style=color:#f92672>&amp;</span>ci;
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>           TestHandler(CompilerInstance <span style=color:#f92672>&amp;</span>ci) <span style=color:#f92672>:</span>ci(ci) {}
</span></span><span style=display:flex><span>           
</span></span><span style=display:flex><span>           <span style=color:#75715e>//判断是否是用户源文件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>           <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>isUserSourceCode</span>(<span style=color:#66d9ef>const</span> string filename) {
</span></span><span style=display:flex><span>               <span style=color:#75715e>//文件名不为空
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>               <span style=color:#66d9ef>if</span> (filename.empty()) <span style=color:#66d9ef>return</span>  false;
</span></span><span style=display:flex><span>               <span style=color:#75715e>//非xcode中的源码都认为是用户的
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>               <span style=color:#66d9ef>if</span> (filename.find(<span style=color:#e6db74>&#34;/Applications/Xcode_14.0.app/&#34;</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>) <span style=color:#66d9ef>return</span> false;
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>return</span>  true;
</span></span><span style=display:flex><span>           }
</span></span><span style=display:flex><span>     
</span></span><span style=display:flex><span>           <span style=color:#75715e>// 代码检查的回调方法
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>           <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>(<span style=color:#66d9ef>const</span> MatchFinder<span style=color:#f92672>::</span>MatchResult <span style=color:#f92672>&amp;</span>Result) {
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>               <span style=color:#75715e>// 检查类名(Interface)，不能带有下划线
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>               <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>const</span> ObjCInterfaceDecl <span style=color:#f92672>*</span>decl <span style=color:#f92672>=</span> Result.Nodes.getNodeAs<span style=color:#f92672>&lt;</span>ObjCInterfaceDecl<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;ObjCInterfaceDecl&#34;</span>)) {
</span></span><span style=display:flex><span>                   string filename <span style=color:#f92672>=</span> ci.getSourceManager().getFilename(decl<span style=color:#f92672>-&gt;</span>getSourceRange().getBegin()).str();
</span></span><span style=display:flex><span>                   <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span>isUserSourceCode(filename) ) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>                   size_t pos <span style=color:#f92672>=</span> decl<span style=color:#f92672>-&gt;</span>getName().find(<span style=color:#e6db74>&#39;_&#39;</span>);
</span></span><span style=display:flex><span>                   <span style=color:#66d9ef>if</span> (pos <span style=color:#f92672>!=</span> StringRef<span style=color:#f92672>::</span>npos) {
</span></span><span style=display:flex><span>                       DiagnosticsEngine <span style=color:#f92672>&amp;</span>D <span style=color:#f92672>=</span> ci.getDiagnostics();
</span></span><span style=display:flex><span>                       <span style=color:#75715e>// 获取位置
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>                       SourceLocation loc <span style=color:#f92672>=</span> decl<span style=color:#f92672>-&gt;</span>getLocation().getLocWithOffset(pos);
</span></span><span style=display:flex><span>                       D.Report(loc, D.getCustomDiagID(DiagnosticsEngine<span style=color:#f92672>::</span>Warning, <span style=color:#e6db74>&#34;ACKClangPlugin：类名中不能带有下划线&#34;</span>));
</span></span><span style=display:flex><span>                   }
</span></span><span style=display:flex><span>               }
</span></span><span style=display:flex><span>               <span style=color:#75715e>// 检查变量(Interface)，不能带有下划线
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>               <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>const</span> VarDecl <span style=color:#f92672>*</span>decl <span style=color:#f92672>=</span> Result.Nodes.getNodeAs<span style=color:#f92672>&lt;</span>VarDecl<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;VarDecl&#34;</span>)) {
</span></span><span style=display:flex><span>                   string filename <span style=color:#f92672>=</span> ci.getSourceManager().getFilename(decl<span style=color:#f92672>-&gt;</span>getSourceRange().getBegin()).str();
</span></span><span style=display:flex><span>                   <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span>isUserSourceCode(filename) ) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>                   size_t pos <span style=color:#f92672>=</span> decl<span style=color:#f92672>-&gt;</span>getName().find(<span style=color:#e6db74>&#39;_&#39;</span>);
</span></span><span style=display:flex><span>                   <span style=color:#66d9ef>if</span> (pos <span style=color:#f92672>!=</span> StringRef<span style=color:#f92672>::</span>npos <span style=color:#f92672>&amp;&amp;</span> pos <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>                       DiagnosticsEngine <span style=color:#f92672>&amp;</span>D <span style=color:#f92672>=</span> ci.getDiagnostics();
</span></span><span style=display:flex><span>                       SourceLocation loc <span style=color:#f92672>=</span> decl<span style=color:#f92672>-&gt;</span>getLocation().getLocWithOffset(pos);
</span></span><span style=display:flex><span>                       D.Report(loc, D.getCustomDiagID(DiagnosticsEngine<span style=color:#f92672>::</span>Warning, <span style=color:#e6db74>&#34;ACKClangPlugin：请使用驼峰命名，不建议使用下划线&#34;</span>));
</span></span><span style=display:flex><span>                       D.Report(loc, D.getCustomDiagID(DiagnosticsEngine<span style=color:#f92672>::</span>Error, <span style=color:#e6db74>&#34;ACKClangPlugin: 请使用驼峰命名，不建议使用下划线&#34;</span>));
</span></span><span style=display:flex><span>                   }
</span></span><span style=display:flex><span>               }
</span></span><span style=display:flex><span>           }
</span></span><span style=display:flex><span>       };
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>       <span style=color:#75715e>// 定义语法树的接受事件
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestASTConsumer</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> ASTConsumer{
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>private</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>           MatchFinder matcher;
</span></span><span style=display:flex><span>           TestHandler handler;
</span></span><span style=display:flex><span>           
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>           TestASTConsumer(CompilerInstance <span style=color:#f92672>&amp;</span>ci) <span style=color:#f92672>:</span>handler(ci) {
</span></span><span style=display:flex><span>               matcher.addMatcher(objcInterfaceDecl().bind(<span style=color:#e6db74>&#34;ObjCInterfaceDecl&#34;</span>), <span style=color:#f92672>&amp;</span>handler);
</span></span><span style=display:flex><span>               matcher.addMatcher(varDecl().bind(<span style=color:#e6db74>&#34;VarDecl&#34;</span>), <span style=color:#f92672>&amp;</span>handler);
</span></span><span style=display:flex><span>               matcher.addMatcher(objcMethodDecl().bind(<span style=color:#e6db74>&#34;ObjCMethodDecl&#34;</span>), <span style=color:#f92672>&amp;</span>handler);
</span></span><span style=display:flex><span>           }
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>HandleTranslationUnit</span>(ASTContext <span style=color:#f92672>&amp;</span>Ctx) {
</span></span><span style=display:flex><span>               printf(<span style=color:#e6db74>&#34;ACKClangPlugin: All ASTs has parsed.&#34;</span>);
</span></span><span style=display:flex><span>               DiagnosticsEngine <span style=color:#f92672>&amp;</span>D <span style=color:#f92672>=</span> Ctx.getDiagnostics();
</span></span><span style=display:flex><span>               matcher.matchAST(Ctx);
</span></span><span style=display:flex><span>           }
</span></span><span style=display:flex><span>       };
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>       <span style=color:#75715e>// 定义触发插件的动作
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>       <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TestAction</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> PluginASTAction{
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>           unique_ptr<span style=color:#f92672>&lt;</span>ASTConsumer<span style=color:#f92672>&gt;</span> CreateASTConsumer(CompilerInstance <span style=color:#f92672>&amp;</span>CI,
</span></span><span style=display:flex><span>                                                   StringRef InFile){
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>return</span> unique_ptr<span style=color:#f92672>&lt;</span>TestASTConsumer<span style=color:#f92672>&gt;</span> (<span style=color:#66d9ef>new</span> TestASTConsumer(CI));
</span></span><span style=display:flex><span>               
</span></span><span style=display:flex><span>           }
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>bool</span> <span style=color:#a6e22e>ParseArgs</span>(<span style=color:#66d9ef>const</span> CompilerInstance <span style=color:#f92672>&amp;</span>CI,
</span></span><span style=display:flex><span>                       <span style=color:#66d9ef>const</span> std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>string<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&amp;</span>arg){
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>return</span> true;
</span></span><span style=display:flex><span>           }
</span></span><span style=display:flex><span>       };
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>   
</span></span><span style=display:flex><span>   <span style=color:#75715e>// 告知clang,注册一个新的plugin
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#66d9ef>static</span> FrontendPluginRegistry<span style=color:#f92672>::</span>Add<span style=color:#f92672>&lt;</span>ACKClangPlugin<span style=color:#f92672>::</span>TestAction<span style=color:#f92672>&gt;</span>
</span></span><span style=display:flex><span>   X(<span style=color:#e6db74>&#34;ACKClangPlugin&#34;</span>, <span style=color:#e6db74>&#34;ACKClangPlugin a new Plugin&#34;</span>);
</span></span><span style=display:flex><span>   <span style=color:#75715e>// X 变量名，可随便写，也可以写自己有意思的名称
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// ACKClangPlugin  插件名称，️很重要，这个是对外的名称
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>   <span style=color:#75715e>// ACKClangPlugin a new Plugin  插件备注   
</span></span></span></code></pre></div><ul><li>scheme中选择ACKClangPlugin，编译。</li><li>记录编译出的ACKClangPlugin.dylib路径<ul><li>/Users/xxx/Desktop/llvm-all/llvm-project/build/Debug/lib/ACKClangPlugin.dylib</li></ul></li></ul><h1 id=xcode集成clang插件>Xcode集成Clang插件<a hidden class=anchor aria-hidden=true href=#xcode集成clang插件>#</a></h1><h2 id=指定clang>指定clang<a hidden class=anchor aria-hidden=true href=#指定clang>#</a></h2><ul><li>Xcode默认使用的是自带的clang前端，所以在Xcode中我们需要增加CC和CXX参数来指定我们自己的clang地址。</li><li>在配置文件中新增CC和CXX绝对路径，也就是clang和clang++的绝对路径</li><li>注：在编译llvm-project中有记录<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  /// 注意：key为大写。
</span></span><span style=display:flex><span>  CC <span style=color:#f92672>=</span> /Users/wangzeyong/Desktop/llvm-all/llvm-project/build/Debug/bin/clang
</span></span><span style=display:flex><span>  CXX <span style=color:#f92672>=</span>/Users/wangzeyong/Desktop/llvm-all/llvm-project/build/Debug/bin/clang++
</span></span></code></pre></div><img loading=lazy src=./image2022-12-8_18-49-37.png alt=clang></li></ul><h2 id=关闭-enable-index-while-building-functionality>关闭 Enable Index-While-Building Functionality<a hidden class=anchor aria-hidden=true href=#关闭-enable-index-while-building-functionality>#</a></h2><p><img loading=lazy src=./image2022-12-8_18-54-41.png alt=close></p><h2 id=指定需要额外加载的clang-plugin>指定需要额外加载的clang plugin<a hidden class=anchor aria-hidden=true href=#指定需要额外加载的clang-plugin>#</a></h2><ul><li>在配置文件中搜索other c即可快速查询</li><li>增加如下内容<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>  -Xclang -load 插件地址<span style=color:#f92672>(</span>dylib的地址<span style=color:#f92672>)</span> -Xclang -add-plugin -Xclang 插件名
</span></span><span style=display:flex><span>  // 实例
</span></span><span style=display:flex><span>  -Xclang -load -Xclang /Volumes/ExDisk/LLVM/llvm/llvm_xcode/Debug/lib/TestPlugin1.dylib -Xclang -add-plugin -Xclang TestPlugin
</span></span></code></pre></div><img loading=lazy src=./image2022-12-8_18-56-34.png alt=other_c></li></ul><h2 id=编译结果>编译结果<a hidden class=anchor aria-hidden=true href=#编译结果>#</a></h2><p><img loading=lazy src=./image2022-12-8_18-57-22.png alt=resule></p><h1 id=我的第一个libtooling>我的第一个LibTooling<a hidden class=anchor aria-hidden=true href=#我的第一个libtooling>#</a></h1><h2 id=使用ninja编译llvm项目>使用ninja编译llvm项目<a hidden class=anchor aria-hidden=true href=#使用ninja编译llvm项目>#</a></h2><ul><li>cd llvm-project</li><li>mkdir ninja</li><li>cd ninja</li><li>cmake -DLLVM_ENABLE_PROJECTS=clang -DCMAKE_BUILD_TYPE=Release -G Ninja ../llvm<ul><li>如果没有ninja，则需要安装。brew install ninja</li></ul></li><li>ninja</li><li>ninja install</li></ul><h2 id=创建libtooling>创建libtooling<a hidden class=anchor aria-hidden=true href=#创建libtooling>#</a></h2><ul><li>cd llvm-project</li><li>cd clang/tools</li><li>mkdir ACKLibTooling</li><li>cd ACKLibTooling</li><li>touch ACKLibTooling.cpp</li><li>touch CMakeLists.txt</li><li>code CMakeLists.txt (打开文件，并添加下一步的描述)<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>  set(LLVM_LINK_COMPONENTS support)
</span></span><span style=display:flex><span>  add_clang_tool(ACKLibTooling
</span></span><span style=display:flex><span>    ACKLibTooling.cpp
</span></span><span style=display:flex><span>  )
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  clang_target_link_libraries(ACKLibTooling
</span></span><span style=display:flex><span>    PRIVATE
</span></span><span style=display:flex><span>    clangAST
</span></span><span style=display:flex><span>    clangASTMatchers
</span></span><span style=display:flex><span>    clangBasic
</span></span><span style=display:flex><span>    clangFrontend
</span></span><span style=display:flex><span>    clangSerialization
</span></span><span style=display:flex><span>    clangTooling
</span></span><span style=display:flex><span>  )
</span></span></code></pre></div><ul><li>cd ../</li><li>echo &lsquo;add_subdirectory(ACKLibTooling)&rsquo; &#187; CMakeLists.txt</li><li>code ACKLibTooling.cpp (打开文件，并添加下一步的代码)</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span><span style=color:#75715e>// Declares clang::SyntaxOnlyAction.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;clang/Frontend/FrontendActions.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;clang/Tooling/CommonOptionsParser.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;clang/Tooling/Tooling.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// Declares llvm::cl::extrahelp.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;llvm/Support/CommandLine.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;clang/ASTMatchers/ASTMatchers.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;clang/ASTMatchers/ASTMatchFinder.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> llvm;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> clang;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> clang<span style=color:#f92672>::</span>tooling;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>using</span> <span style=color:#66d9ef>namespace</span> clang<span style=color:#f92672>::</span>ast_matchers;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// Apply a custom category to all command-line options so that they are the
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// only ones displayed.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>static</span> llvm<span style=color:#f92672>::</span>cl<span style=color:#f92672>::</span>OptionCategory MyToolCategory(<span style=color:#e6db74>&#34;my-tool options&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// CommonOptionsParser declares HelpMessage with a description of the common
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// command-line options related to the compilation database and input files.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#75715e>// It&#39;s nice to have this help message in all tools.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>static</span> cl<span style=color:#f92672>::</span>extrahelp CommonHelp(CommonOptionsParser<span style=color:#f92672>::</span>HelpMessage);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// A help message for this specific tool can be added afterwards.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>static</span> cl<span style=color:#f92672>::</span>extrahelp MoreHelp(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>More help text...</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  StatementMatcher LoopMatcher <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  forStmt(hasLoopInit(declStmt(hasSingleDecl(varDecl(
</span></span><span style=display:flex><span>      hasInitializer(integerLiteral(equals(<span style=color:#ae81ff>0</span>)))))))).bind(<span style=color:#e6db74>&#34;forLoop&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LoopPrinter</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> MatchFinder<span style=color:#f92672>::</span>MatchCallback {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> run(<span style=color:#66d9ef>const</span> MatchFinder<span style=color:#f92672>::</span>MatchResult <span style=color:#f92672>&amp;</span>Result) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// 绑定for循环
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>const</span> ForStmt <span style=color:#f92672>*</span>FS <span style=color:#f92672>=</span> Result.Nodes.getNodeAs<span style=color:#f92672>&lt;</span>clang<span style=color:#f92672>::</span>ForStmt<span style=color:#f92672>&gt;</span>(<span style=color:#e6db74>&#34;forLoop&#34;</span>))
</span></span><span style=display:flex><span>          <span style=color:#75715e>// 打印for循环表达式的抽象语法树
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>          FS<span style=color:#f92672>-&gt;</span>dump();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span> <span style=color:#f92672>**</span>argv) {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>auto</span> ExpectedParser <span style=color:#f92672>=</span> CommonOptionsParser<span style=color:#f92672>::</span>create(argc, argv, MyToolCategory);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (<span style=color:#f92672>!</span>ExpectedParser) {
</span></span><span style=display:flex><span>      <span style=color:#75715e>// Fail gracefully for unsupported options.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>      llvm<span style=color:#f92672>::</span>errs() <span style=color:#f92672>&lt;&lt;</span> ExpectedParser.takeError();
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  CommonOptionsParser<span style=color:#f92672>&amp;</span> OptionsParser <span style=color:#f92672>=</span> ExpectedParser.get();
</span></span><span style=display:flex><span>  ClangTool Tool(OptionsParser.getCompilations(),
</span></span><span style=display:flex><span>                  OptionsParser.getSourcePathList());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  LoopPrinter Printer;
</span></span><span style=display:flex><span>  MatchFinder Finder;
</span></span><span style=display:flex><span>  Finder.addMatcher(LoopMatcher, <span style=color:#f92672>&amp;</span>Printer);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> Tool.run(newFrontendActionFactory(<span style=color:#f92672>&amp;</span>Finder).get());
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ul><li>cd llvm-project/ninja</li><li>ninja</li><li>此时可见编译好的libtooling在llvm-project/ninja/bin/目录下
<img loading=lazy src=./image2022-12-14_17-21-36.png alt=libtooling></li></ul><h2 id=使用libtooling>使用LibTooling<a hidden class=anchor aria-hidden=true href=#使用libtooling>#</a></h2><ul><li>创建一个测试文件test.m</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>  <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>void</span>)
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>int</span> a <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>for</span>(<span style=color:#66d9ef>int</span> i<span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>10</span>; <span style=color:#f92672>++</span>i) {
</span></span><span style=display:flex><span>          a <span style=color:#f92672>+=</span> i;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> a;
</span></span><span style=display:flex><span>  }
</span></span></code></pre></div><ul><li>./bin/ACKLibTooling test.m<ul><li>for循环的抽象语法树被打印出来
<img loading=lazy src=./image2022-12-14_17-24-52.png alt=re></li></ul></li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://jiadingyi.github.io/Tips/tags/llvm/>llvm</a></li></ul><nav class=paginav><a class=prev href=https://jiadingyi.github.io/Tips/post/%E5%86%99%E7%BB%99ioser%E7%9A%84%E5%AE%9E%E8%B7%B5%E6%8C%87%E5%8D%97-%E5%A6%82%E4%BD%95%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8Bandroid%E9%A1%B9%E7%9B%AE/><span class=title>« Prev</span><br><span>写给iOSer的实践指南 如何快速上手Android项目</span></a>
<a class=next href=https://jiadingyi.github.io/Tips/post/%E7%8E%A9%E8%BD%ACstablediffusion/><span class=title>Next »</span><br><span>玩转StableDiffusion</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share 我的第一个Clang插件 on twitter" href="https://twitter.com/intent/tweet/?text=%e6%88%91%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aaClang%e6%8f%92%e4%bb%b6&url=https%3a%2f%2fjiadingyi.github.io%2fTips%2fpost%2f%25E6%2588%2591%25E7%259A%2584%25E7%25AC%25AC%25E4%25B8%2580%25E4%25B8%25AAclang%25E6%258F%2592%25E4%25BB%25B6%2f&hashtags=llvm"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 我的第一个Clang插件 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fjiadingyi.github.io%2fTips%2fpost%2f%25E6%2588%2591%25E7%259A%2584%25E7%25AC%25AC%25E4%25B8%2580%25E4%25B8%25AAclang%25E6%258F%2592%25E4%25BB%25B6%2f&title=%e6%88%91%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aaClang%e6%8f%92%e4%bb%b6&summary=%e6%88%91%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aaClang%e6%8f%92%e4%bb%b6&source=https%3a%2f%2fjiadingyi.github.io%2fTips%2fpost%2f%25E6%2588%2591%25E7%259A%2584%25E7%25AC%25AC%25E4%25B8%2580%25E4%25B8%25AAclang%25E6%258F%2592%25E4%25BB%25B6%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 我的第一个Clang插件 on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fjiadingyi.github.io%2fTips%2fpost%2f%25E6%2588%2591%25E7%259A%2584%25E7%25AC%25AC%25E4%25B8%2580%25E4%25B8%25AAclang%25E6%258F%2592%25E4%25BB%25B6%2f&title=%e6%88%91%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aaClang%e6%8f%92%e4%bb%b6"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 我的第一个Clang插件 on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fjiadingyi.github.io%2fTips%2fpost%2f%25E6%2588%2591%25E7%259A%2584%25E7%25AC%25AC%25E4%25B8%2580%25E4%25B8%25AAclang%25E6%258F%2592%25E4%25BB%25B6%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 我的第一个Clang插件 on whatsapp" href="https://api.whatsapp.com/send?text=%e6%88%91%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aaClang%e6%8f%92%e4%bb%b6%20-%20https%3a%2f%2fjiadingyi.github.io%2fTips%2fpost%2f%25E6%2588%2591%25E7%259A%2584%25E7%25AC%25AC%25E4%25B8%2580%25E4%25B8%25AAclang%25E6%258F%2592%25E4%25BB%25B6%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 我的第一个Clang插件 on telegram" href="https://telegram.me/share/url?text=%e6%88%91%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aaClang%e6%8f%92%e4%bb%b6&url=https%3a%2f%2fjiadingyi.github.io%2fTips%2fpost%2f%25E6%2588%2591%25E7%259A%2584%25E7%25AC%25AC%25E4%25B8%2580%25E4%25B8%25AAclang%25E6%258F%2592%25E4%25BB%25B6%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share 我的第一个Clang插件 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%e6%88%91%e7%9a%84%e7%ac%ac%e4%b8%80%e4%b8%aaClang%e6%8f%92%e4%bb%b6&u=https%3a%2f%2fjiadingyi.github.io%2fTips%2fpost%2f%25E6%2588%2591%25E7%259A%2584%25E7%25AC%25AC%25E4%25B8%2580%25E4%25B8%25AAclang%25E6%258F%2592%25E4%25BB%25B6%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://jiadingyi.github.io/Tips/>Tips</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>